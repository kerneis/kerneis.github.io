<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Gabriel Kerneis</title><link>https://gabriel.kerneis.info/</link><description>Gabriel Kerneis' website</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>contact@gabriel.kerneis.info (Gabriel Kerneis)</managingEditor><webMaster>contact@gabriel.kerneis.info (Gabriel Kerneis)</webMaster><atom:link href="https://gabriel.kerneis.info/index.xml" rel="self" type="application/rss+xml"/><item><title>TPM remote attestation over Bluetooth</title><link>https://gabriel.kerneis.info/2021/11/local_attestation/</link><pubDate>Mon, 29 Nov 2021 10:00:00 +0100</pubDate><author>Author</author><guid>https://gabriel.kerneis.info/2021/11/local_attestation/</guid><description><![CDATA[<p>How can you be sure that the software running on your computer has not been tampered with since you installed it?
Even if your disk is encrypted, how can you be sure that the password prompt at boot is not a trap planted by an evil third-party that will exfiltrate all your data?
Those are the some of the questions that the field of &ldquo;secure computing&rdquo; tries to address.
The answers are built through complex combinations of hardware (<a href="https://en.wikipedia.org/wiki/Central_processing_unit" target="_blank" rel="noopener noreffer">CPU</a>, <a href="https://en.wikipedia.org/wiki/Trusted_Platform_Module" target="_blank" rel="noopener noreffer">TPM</a>, flash memory) and software (<a href="https://en.wikipedia.org/wiki/BIOS" target="_blank" rel="noopener noreffer">BIOS</a>, <a href="https://en.wikipedia.org/wiki/Operating_system" target="_blank" rel="noopener noreffer">OS</a>) components.</p>
<p>In this post, IÂ will focus on a smaller part of the problem: measured boot and remote attestation.
How do you prove to a remote third-party that your computer is the one it has on record, and that it runs the sofware it expects?
This third-party may be your network administrator, who wants to deny intruder or compromised machines on the intranet.
Or it could be yourself facing your computer: what if you could use you a trusted device (eg. your phone) to communicate with your machine over bluetooth to make sure it has not been swaped or altered in your hotel room while you were enjoying a nice dinner with other conference attendees?
I recently got interested in the latter use-case, so I started researching existing standards and solutions.
<em>Spoiler:</em> I may need to build this app myself.</p>
<p>What follows is my understanding of the current landscape for remote attestation, from a practical perspective:
what standards exist, what implementations are available, and what remains to be done to enable local verification of measured boot over bluetooth.
I will only address Linux solutions; you can read more about Windows secure boot on <a href="https://igor-blue.github.io/2021/02/04/secure-boot.html" target="_blank" rel="noopener noreffer">Igor&rsquo;s blog</a>.</p>
<blockquote>
<p><strong>Background</strong>: if you never used a TPM or need a refresher on how it works, I cannot recommend enough the <a href="https://google.github.io/tpm-js" target="_blank" rel="noopener noreffer">TPM-JS tutorial</a> which simulates a TPM in your browser.
The section on <a href="https://google.github.io/tpm-js/#pg_attestation" target="_blank" rel="noopener noreffer">remote attestation</a> is of course especially relevant here, but it&rsquo;s worth starting from the very begining.
If you prefer a video, watch <a href="https://www.youtube.com/watch?v=FobfM9S9xSI" target="_blank" rel="noopener noreffer">Matthew Garret at LCA 2020</a>.</p>
</blockquote>
<h2 id="existing-standards">Existing standards</h2>
<h3 id="trusted-computing-group-tcg">Trusted Computing Group (TCG)</h3>
<p>The <a href="https://trustedcomputinggroup.org/" target="_blank" rel="noopener noreffer">Trusted Computing Group</a> is an organisation publishing open standards and specifications about secure computing.</p>
<p>Specifications from the TCG provide the basic building blocks to communicate with a TPM.
For instance, the <a href="https://trustedcomputinggroup.org/resource/tpm-library-specification/" target="_blank" rel="noopener noreffer">TPM library</a> details the architecture of the TPM, the primitives it implements, and commands to interact with it.
For our use-case of measured boot, the <a href="https://trustedcomputinggroup.org/resource/tcg-pc-client-platform-firmware-integrity-measurement/" target="_blank" rel="noopener noreffer">PC Client Platform Firmware Integrity Measurement</a>
describes how the firmware should keep an event log of what software and cryptographic material is used at various stages of the boot, and attest them using the TPM.
The encoding used to represent attestation messages and the interactions between an attester (eg. your computer) and a verifier (eg. your phone) are defined in the <a href="https://trustedcomputinggroup.org/resource/tcg-tap-information-model/" target="_blank" rel="noopener noreffer">Trusted Attestation Protocol (TAP) Information Model</a>.</p>
<p>However, the Trusted Attestation Protocol only defines the format of the payloads exchanged between attester and verifier.
Likewise, the PC Client FIM specification says nothing of the communication beyond an non-normative comment about
&ldquo;proper selection of transmission protocols [to] maximize interoperability, freshness, and efficiency&rdquo;.
The choice of the transport and application layers is left unspecified by documents from the TCG.</p>
<h3 id="remote-attestation-procedures-rats">Remote Attestation Procedures (RATS)</h3>
<p>The <a href="https://datatracker.ietf.org/wg/rats/about/" target="_blank" rel="noopener noreffer">IETF RATS Working Group</a> seeks to standardize formats for remote attestations.
Its charter is broad, ranging from FIDO to TPM and Android Keystore, but for now it seems very focused on TPM-related applications.
Since the role of the IETF is to standardize network protocols, this sounds perfect for our interest.</p>
<p>IETF working groups start with draft standards are proposed by individual authors.
Those drafts are then adopted by the WG to be improved collectively,
and finally (after many stages of reviews) accepted as official RFC documents.
I have only reviewed the drafts adopted by RATS, because finding unadopted drafts is more tedious<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>;
none of them have reached the stage of a final RFC yet.</p>
<p>The <a href="https://tools.ietf.org/html/draft-ietf-rats-architecture" target="_blank" rel="noopener noreffer">Architecture draft</a> sets some definitions and goals, a framework of common terminology used in the other drafts.
The <a href="https://datatracker.ietf.org/doc/html/draft-ietf-rats-reference-interaction-models" target="_blank" rel="noopener noreffer">Reference Interaction Models draft</a> defines three approaches to communicate between an attester and a verifier:
challenge/response, uni-directional, and streaming.
Challenge/response remote attestation, also known as CHARRA, uses a nonce sent from the verifier to the attester to ensure freshness and avoid replay attacks.
Uni-directional and streaming rely on synchronised clocks instead.</p>
<p>Both of those drafts are worded in very general terms and do not mandate specific network protocols.
The <a href="https://datatracker.ietf.org/doc/html/draft-ietf-rats-reference-interaction-models#appendix-A" target="_blank" rel="noopener noreffer">Appendix A of RIM</a> sketches a
<a href="https://datatracker.ietf.org/doc/html/rfc8610" target="_blank" rel="noopener noreffer">CDDL</a> specification for a simple <a href="http://coap.technology/" target="_blank" rel="noopener noreffer">CoAP</a> Challenge/Response Interaction,
but it&rsquo;s only an informative appendix due to be deleted from the final specification.
An implementation of this protocol is <a href="https://github.com/Fraunhofer-SIT/charra" target="_blank" rel="noopener noreffer">available as a proof-of-concept</a>.</p>
<p>RATS has adopted two more drafts: <a href="https://datatracker.ietf.org/doc/html/draft-ietf-rats-tpm-based-network-device-attest" target="_blank" rel="noopener noreffer">TPM-based network device attestation</a>
and its <a href="https://datatracker.ietf.org/doc/html/draft-ietf-rats-yang-tpm-charra/" target="_blank" rel="noopener noreffer">YANG counterpart</a>.
Unlike the previous drafts, those two go into much more details about defining an actual, interroperable network protocol.
Unfortunately, they are not designed for the use-case at hand: the attester is assumed to be (a fleet of) network devices, such as switches, routers and servers.
They are built on top of Netconf, or its modern alternative Restconf, which are widely used by network operators.
There doesn&rsquo;t seem to be a prototype implementation available.</p>
<p>For now we are therefore left with a choice between a full-featured solution over-engineered for our use-case,
and a reasonable technological stack (CoAP) with a prototype implementation but no standardization effort.
The situation is not as grim as it may seem though: IETF working groups are opened to contribution,
so if we could build upon this prototype in an interoperable way,
it may then be possible to propose a draft for adoption to RATS.</p>
<h3 id="constrained-application-protocol-coap-a-idcoapa">Constrained Application Protocol (CoAP) <a id="coap"></a></h3>
<p>The <a href="http://coap.technology/" target="_blank" rel="noopener noreffer">Constrained Application Protocol (CoAP)</a> is a specialized web transfer protocol for use with constrained nodes,
defined in <a href="https://datatracker.ietf.org/doc/html/rfc7252/" target="_blank" rel="noopener noreffer">RFC 7252</a>.
By default, it runs over UDP or DTLS but is designed to be lightweight and portable to other transport layers such as TCP or SMS.
It also offers a flexible data model.
The <a href="https://github.com/Fraunhofer-SIT/charra" target="_blank" rel="noopener noreffer">CHARRA prototype</a> uses CoAP over DTLS, and <a href="http://cbor.io/" target="_blank" rel="noopener noreffer">CBOR</a> (<a href="https://datatracker.ietf.org/doc/html/rfc8949/" target="_blank" rel="noopener noreffer">RFC 8949</a>) to encode the payload.</p>
<p>If we want to port the proposed protocol to <a href="https://en.wikipedia.org/wiki/Bluetooth_Low_Energy" target="_blank" rel="noopener noreffer">Bluetooth Low Energy (BLE)</a>, two approaches are therefore possible:
encapsulating CoAP over BLE, or bringing up an IP stack on top of BLE.</p>
<p>There is no standard to encapsulate CoAP over BLE <a href="https://en.wikipedia.org/wiki/Bluetooth_Low_Energy#Software_model" target="_blank" rel="noopener noreffer">GATT</a>, the client/server part of the BLE protocol.
The following solutions have been proposed:</p>
<ul>
<li>a <a href="https://ieeexplore.ieee.org/abstract/document/8190936" target="_blank" rel="noopener noreffer">Samsung research paper</a> (2017, no code),</li>
<li>a <a href="https://datatracker.ietf.org/doc/html/draft-amsuess-core-coap-over-gatt" target="_blank" rel="noopener noreffer">draft proposal</a> in <a href="https://datatracker.ietf.org/wg/core/about/" target="_blank" rel="noopener noreffer">IETF CoRE WG</a>  (2020, <a href="https://datatracker.ietf.org/doc/slides-109-core-sessb-coap-over-gatt/" target="_blank" rel="noopener noreffer">slides</a>, <a href="https://gitlab.com/chrysn/coap-gatt-demo" target="_blank" rel="noopener noreffer">code</a>),</li>
<li>an implementation using the <a href="https://www.maibornwolff.de/en/blog/talk-coap-me-iot-over-bluetooth-low-energy" target="_blank" rel="noopener noreffer">standard layers SLIP and UART for encoding</a> (2021, some code snippets).</li>
</ul>
<p>The CoRE draft sounds promising, but the author was waiting to see if browser vendors agreed on a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Bluetooth_API" target="_blank" rel="noopener noreffer">W3C specification for BLE</a> â
and Mozilla is <a href="https://github.com/mozilla/standards-positions/issues/95" target="_blank" rel="noopener noreffer">not too keen</a> on accepting Chrome&rsquo;s proposal.
A reimplemantation using the SLIP+UART approach would probably be reasonably straightforward, but not using out-of-the-box standards.</p>
<p>On the other hand, there is a well-known standard for IPv6 over BLE: <a href="https://en.wikipedia.org/wiki/6LoWPAN" target="_blank" rel="noopener noreffer">6LoWPAN</a> over BLE (<a href="https://datatracker.ietf.org/doc/html/rfc7668" target="_blank" rel="noopener noreffer">RFC 7668</a>).
The computer side could be implemented with <a href="https://github.com/NordicSemiconductor/Linux-ble-6lowpan-joiner" target="_blank" rel="noopener noreffer">bluetooth_6lowpand</a> and the Linux <code>bluetooth_6lowpan</code> kernel module.
There is currently no implementation for Android, but this may change soon:
<a href="https://diglib.tugraz.at/download.php?id=60a4ea6a34af4&amp;location=browse" target="_blank" rel="noopener noreffer">Alexander Wieland</a> wrote one in 2020 as part of his master thesis, and seems willing to open-source it in the near future.
His implementation used introspection to access a private BLE API of Android (<code>CreateL2capChannel</code>), but Android 10 made the API official, allowing future-proof use.</p>
<figure><figcaption>
            <h4>TPM remote attestation over BLE stack</h4>
        </figcaption>
</figure>

<h2 id="existing-solutions">Existing solutions</h2>
<p>There is a number of tools to perform remote attestation over IP.
For instance, <a href="https://github.com/google/go-tpm-tools" target="_blank" rel="noopener noreffer">go-tpm-tools</a> provide a self-contained solution in Go for both the client and server.
<a href="https://github.com/google/go-attestation/" target="_blank" rel="noopener noreffer">go-attestation</a> builds upon it to manage the certificates attesting a device identity.
However, they are not directly useful for local validation.</p>
<p><a href="https://mjg59.dreamwidth.org/" target="_blank" rel="noopener noreffer">Matthew Garrett</a>, who worked in the teams building those tools during his tenure at Google,
prototyped several techniques to perform remote attestation locally.
He introduced the idea of <a href="https://mjg59.dreamwidth.org/35742.html" target="_blank" rel="noopener noreffer">TPM TOTP</a>, using a Timed One-Time-Password to confirm the state of the TPM
It was later re-implemented as a stand-alone tool, <a href="https://github.com/tpm2-software/tpm2-totp" target="_blank" rel="noopener noreffer">tpm2-totp</a>,
and <a href="https://trmm.net/Tpmtotp/" target="_blank" rel="noopener noreffer">is used by Trammell Hudson</a> for his secure open-source firmware project <a href="https://osresearch.net/" target="_blank" rel="noopener noreffer">Heads</a>.
Trammell&rsquo;s other project, <a href="https://safeboot.dev/" target="_blank" rel="noopener noreffer">safeboot</a> also provides tools for <a href="https://safeboot.dev/attestation/" target="_blank" rel="noopener noreffer">remote attestation</a> but they are not used for verification during the boot phase as far as IÂ can tell.</p>
<p>Matthew Garrett also implemented <a href="https://mjg59.dreamwidth.org/54203.html" target="_blank" rel="noopener noreffer">a prototype of remote attestation over BLE</a>, which was the initial inspiration for this blog post:
his <a href="https://www.youtube.com/watch?v=FobfM9S9xSI" target="_blank" rel="noopener noreffer">talk and demo</a> give good insights into why this approach is preferable to TPM-TOTP (in particular it provides more flexible policies, and a better understanding of what changed in case the laptop is compromised).</p>
<p><a href="https://fobnail.3mdeb.com/" target="_blank" rel="noopener noreffer">Fobnail</a> is a research project by <a href="https://3mdeb.com/" target="_blank" rel="noopener noreffer">3mdeb</a> to implement a USB token performing remote attestation.
They want to use <a href="https://github.com/Fraunhofer-SIT/charra" target="_blank" rel="noopener noreffer">CHARRA</a> for the remote attestation, but the project is still in a very early stage.
Their milestones do not explain precisely how they plan to encapsulate CHARRA (CoAP) over USB.<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>
You can watch <a href="https://www.youtube.com/watch?v=xZoCtNV8Qs0&amp;t=3660s" target="_blank" rel="noopener noreffer">their talk at the latest Trenchboot summit</a>,
with a discussion at the end about replacing CHARRA with a minimalistic protocol over NFC, USB or BLE.</p>
<h2 id="next-steps">Next steps</h2>
<p>I think the CoAP protocol defined in <a href="https://datatracker.ietf.org/doc/html/draft-ietf-rats-reference-interaction-models#appendix-A" target="_blank" rel="noopener noreffer">draft-ietf-rats-reference-interaction-model</a> is a good stepping stone for this work.
As explained above, it could be implemented either by encapsulating CoAP directly over BLE, or by running a 6LoWPAN IPv6 stack.
It is not entirely clear which approach is preferable here, and it would be worthwhile to experiment with both.
It may be less hassle and lower overhead to implement a self-contained solution using encapsulation than trying to bring up a 6LoWPAN daemon in initramfs,
but relying on existing standards has the benefit of exercising them in the field, and making them easier to re-use for the next application we come up with.</p>
<p>Once we get a basic prototype working, a lot of thought needs to be given to the provisioning and attestation UI.
Event logs are complex beasts, and it&rsquo;s not obvious to me what PCRs and events you want to validate.
The <a href="https://datatracker.ietf.org/doc/html/draft-ietf-rats-tpm-based-network-device-attest#section-2.4.1" target="_blank" rel="noopener noreffer">reference integrity manifests</a>
defined by RATS may prove useful for this step, but I haven&rsquo;t studied them enough to have a clear opinion yet.</p>
<p>If you are interested in the topic, please reach out to me. If IÂ got anything wrong, let me know!
I am hoping to host an intern working on this topic at some point in the future, so if you are a student in a French instution, don&rsquo;t hesitate to get in touch.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>They are not listed from the WG page, so you need to review the mailing-list archives and meeting notes to find discussions of them.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Update: the developpers told me that they assume IP communication and expect to use a USB network device on top of which they will run an IP stack in Fobnail.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></description></item></channel></rss>